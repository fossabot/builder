import opster
import paramiko
import logging
logging.getLogger("paramiko").setLevel(logging.DEBUG) # for example



def ssh_pub_key(key_file):
    """Creates a string of a public key from the private key file.
    """
    key = paramiko.RSAKey(filename=key_file)
    pub = "{0} {1} autogenerated by polyphemus"
    pub = pub.format(key.get_name(), key.get_base64())
    return pub


@opster.command()
def register(provider=('p', 'aws', 'provider to register')):
    """ Register provider credentials """

    # Import provider method

    import importlib

    try:
        module = importlib.import_module('providers.%s' % provider)
    except ModuleNotFoundError:
        raise RuntimeError('No such provider')
        import sys
        sys.exit(1)

    class_name = get_class_name(provider)
    cls = getattr(module, class_name)
    instance = cls()
    credentials = instance.get_credentials()

    # Write configuration file

    import configparser
    import os

    config = configparser.ConfigParser()
    config[provider] = credentials

    with open(os.path.expanduser('~/.config/builder.cfg'), 'w') as configfile:
        config.write(configfile)

    return True


@opster.command()
def rpm_build(spec=('s', 'spec-file', 'spec file for rpm build process'), target=('t', 'target', 'Operating system targeted by this package')):
    """ Build rpm """

    import os

    current_directory = os.path.dirname(os.path.realpath(__file__))
    mapping_configuration = os.path.join(current_directory, '..', 'MAPPING.ini')

    import configparser

    internal_config = configparser.ConfigParser()
    internal_config.read(mapping_configuration)
    targets = internal_config.sections()
    if not target in targets:
        import sys
        sys.stderr.write('Unsupported platform')
        sys.exit(1)
    else:
        provider = internal_config[target]['provider']

    # Import provider method

    import importlib

    module = importlib.import_module('providers.%s' % provider)
    class_name = get_class_name(provider)
    cls = getattr(module, class_name)
    instance = cls()

    import re
    import sys
    import os
    lines = open(os.path.expanduser(spec)).readlines()
    binary_options = {}
    for line in lines:
        m = re.match(r'^([A-Za-z0-9]+):(.*)', line)
        if m:
            key = m.group(1).strip()
            value = m.group(2).strip()
            binary_options[key] = value

    import configparser
    import os
    import pystache

    config = configparser.ConfigParser()
    config.read(os.path.expanduser('~/.config/builder.cfg'))
    try:
        credentials = config.items(provider)
    except NoSectionError:
        raise RuntimeError('Unregistered provider')
        import sys
        sys.exit(1)

    current_directory = os.path.dirname(os.path.realpath(__file__))

    template = os.path.join(current_directory, '..',
                            'templates', ('%s.tf' % provider))
    user_data = os.path.join(current_directory, '..',
                             'profiles', ('%s.yml' % provider))
    import tempfile
    tmp_file = tempfile.mkstemp()

    key = paramiko.RSAKey.generate(4096)
    key.write_private_key_file(tmp_file[1])

    tf_config = pystache.render(open(template).read(), {
        'credentials': dict(credentials), 'command': {'identifier': internal_config[target]['internal'] },
        'application': {
            'ssh_key': ssh_pub_key(tmp_file[1]),
            'user_data': open(user_data).read().replace('\n', '\\n')
        }
    })

    d = tempfile.mkdtemp()
    with open(os.path.join(d, 'main.tf'), 'w') as tf_file:
        tf_file.write(tf_config)

    import python_terraform as tf
    option_dict = dict()
    # option_dict['input'] = False
    option_dict['auto-approve'] = True
    tf = tf.Terraform(working_dir=d)

    try:
        return_code, stdout, stderr = tf.init()
    except FileNotFoundError:
        raise RuntimeError('Terraform not found')
        import sys
        sys.exit(1)

    try:
        return_code, stdout, stderr = tf.plan(d)
    except FileNotFoundError:
        raise RuntimeError('Terraform not found')
        import sys
        sys.exit(1)

    try:
        return_code, stdout, stderr = tf.apply(d, **option_dict)
    except FileNotFoundError:
        raise RuntimeError('Terraform not found')
        import sys
        sys.exit(1)

    import json
    tfstate = json.loads(open(os.path.join(d, 'terraform.tfstate')).read())

    public_dns = tfstate['modules'][0]['resources']['%s_%s.builder' % (provider.replace('_', ''), instance.__target__)]['primary']['attributes']['ipv4_address']

    client = paramiko.SSHClient()

    # Avoid missing host entry
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    # SSH username
    username = 'root'
    try:
        username = instance.__ssh__user__
    except AttributeError:
        pass

    import time

    while True:
        time.sleep(10)
        print('Waiting 10s for ssh -i %s %s@%s' % (tmp_file[1], username, public_dns))
        try:
            client.connect(
                public_dns, username=username, key_filename=tmp_file[1])
        except Exception as e:
            print(e)
            continue
        else:
            break

    remote_env = {}
    stdin, stdout, stderr = client.exec_command('env')
    for line in stdout.readlines():
        key, value = line.strip().split('=', 1) # split on first occurrence since some var could contain = (ex: DBUS_SESSION_BUS_ADDRESS)
        remote_env[key] = value

    # Wait cloud-init to finish
    # TODO: use a agnostic way (non linux only) to check that instance is ready

    while True:
        stdin, stdout, stderr = client.exec_command('pgrep cloud-init')
        lines = stdout.readlines()
        line_number = len(lines)
        time.sleep(10)
        if line_number == 0:
            break

    cmd = 'mkdir -p %s/rpmbuild/{SPECS,RPMS,SRPMS,SOURCES,BUILD,BUILDROOT}' % remote_env['HOME']
    client.exec_command(cmd)
    sftp = paramiko.SFTPClient.from_transport(client.get_transport())
    sftp.put(spec, '%s/rpmbuild/SPECS/%s' % (remote_env['HOME'], os.path.basename(spec)))

    import urllib.request
    archive = tempfile.mkstemp()
    archive_name = os.path.basename(binary_options['Source0'])
    urllib.request.urlretrieve(binary_options['Source0'], archive[1])
    package = os.path.basename(spec)
    sftp.put(archive[1], '%s/rpmbuild/SOURCES/%s' % (remote_env['HOME'], archive_name))
    stdin, stdout, stderr = client.exec_command(
        'rpmbuild -bp %s/rpmbuild/SPECS/%s' % (remote_env['HOME'], package), get_pty=True)
    for line in stdout.readlines():
        print(line.strip())
    stdin, stdout, stderr = client.exec_command(
        'rpmbuild -bc --short-circuit %s/rpmbuild/SPECS/%s' % (remote_env['HOME'], package), get_pty=True)
    for line in stdout.readlines():
        print(line.strip())
    stdin, stdout, stderr = client.exec_command(
        'rpmbuild -bi --short-circuit %s/rpmbuild/SPECS/%s' % (remote_env['HOME'], package), get_pty=True)
    for line in stdout.readlines():
        print(line.strip())
    stdin, stdout, stderr = client.exec_command(
        'rpmbuild -ba %s/rpmbuild/SPECS/%s' % (remote_env['HOME'], package), get_pty=True)
    files = []
    for line in stdout.readlines():
        print(line.strip())
        if line.startswith('Wrote'):
            _, path = line.split(':')
            files.append(path.strip())

    for binary in files:
        sftp.get(binary, '/tmp/%s' % os.path.basename(binary))

    client.close()

    try:
        return_code, stdout, stderr = tf.destroy(d)
    except FileNotFoundError:
        raise RuntimeError('Terraform not found')
        import sys
        sys.exit(1)

    return True


def cli():
    opster.dispatch()

def get_module_name(name):
    import re
    s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()

def get_class_name(string):
    """
        Note inspired by `StringCase <https://pypi.python.org/pypi/stringcase>`_
    """
    import re
    string = re.sub(r"^[\-_\.]", '', str(string))
    return string[0].upper() + re.sub(r"[\-_\.\s]([a-z])", lambda matched: (matched.group(1)).capitalize(), string[1:])
